// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include clientscripts\mp\_utility;
#include clientscripts\mp\_ambientpackage;
#include clientscripts\mp\_music;
#include clientscripts\mp\_audio;
#include clientscripts\mp\zm_tomb_amb;

main()
{
    snd_set_snapshot( "cmn_fade_in" );
    declareambientroom( "tomb_tunnel" );
    declareambientpackage( "tomb_tunnel" );
    setambientroomreverb( "tomb_tunnel", "tomb_tunnel", 1, 0.75 );
    setambientroomtone( "tomb_tunnel", "amb_cave_wind_2d", 0.3, 0.3 );
    setambientroomcontext( "tomb_tunnel", "ringoff_plr", "indoor" );
    declareambientroom( "tomb_cave" );
    declareambientpackage( "tomb_cave" );
    setambientroomreverb( "tomb_cave", "tomb_cave", 1, 0.75 );
    setambientroomtone( "tomb_cave", "amb_cave_wind_2d", 0.3, 0.3 );
    setambientroomcontext( "tomb_cave", "ringoff_plr", "indoor" );
    declareambientroom( "tomb_spiral_staircase_bot" );
    declareambientpackage( "tomb_spiral_staircase_bot" );
    setambientroomreverb( "tomb_spiral_staircase_bot", "tomb_stairs_big", 1, 0.75 );
    setambientroomtone( "tomb_spiral_staircase_bot", "amb_spiral_rm_air_2d", 0.3, 0.3 );
    setambientroomcontext( "tomb_spiral_staircase_bot", "ringoff_plr", "indoor" );
    declareambientroom( "tomb_robot_head" );
    declareambientpackage( "tomb_robot_head" );
    setambientroomreverb( "tomb_robot_head", "tomb_bot_head", 1, 0.75 );
    setambientroomtone( "tomb_robot_head", "amb_robot_head_2d", 0.3, 0.3 );
    setambientroomcontext( "tomb_robot_head", "ringoff_plr", "indoor" );
    declareambientroom( "tomb_large_chamber" );
    declareambientpackage( "tomb_large_chamber" );
    setambientroomreverb( "tomb_large_chamber", "tomb_cave_2", 1, 0.75 );
    setambientroomcontext( "tomb_large_chamber", "ringoff_plr", "indoor" );
    level thread sndweathertriggersetup();
    level.sndchambermusoverride = undefined;
    declaremusicstate( "WAVE" );
    musicaliasloop( "mus_theatre_underscore", 4, 2 );
    declaremusicstate( "EGG" );
    musicalias( "mus_egg", 1 );
    declaremusicstate( "SILENCE" );
    musicalias( "null", 1 );
    setsoundcontext( "grass", "no_grass" );
    level.sndambientcontextonplayer = ::sndambientcontextonplayer;
    init_audio_clientfields();
    level thread sndstartambience();
    level thread snd_shake_hvy();
    level thread snd_shake_med();
    level thread snd_shake_lgt();
    level thread sndcapturezonetrigs();
    thread snd_play_loopers();
    level thread sndtombbgsetup();
}

sndweathertriggersetup()
{
    thread sndupdateambienttrigger( "tomb_outdoor", 1, "tomb_outdoor", "outdoor", "_outdoor" );
    thread sndupdateambienttrigger( "tomb_bunker_sml", 0, "tomb_bunker_smallroom", "indoor", "_indoor" );
    thread sndupdateambienttrigger( "tomb_bunker_sml_prtl", 0, "tomb_bunker_smallroom", "indoor", "_outdoor" );
    thread sndupdateambienttrigger( "tomb_bunker_med", 0, "tomb_bunker_mediumroom", "indoor", "_indoor" );
    thread sndupdateambienttrigger( "tomb_bunker_med_prtl", 0, "tomb_bunker_mediumroom", "indoor", "_outdoor" );
    thread sndupdateambienttrigger( "tomb_bunker_lrg", 0, "tomb_bunker_largeroom", "indoor", "_indoor" );
    thread sndupdateambienttrigger( "tomb_bunker_lrg_prtl", 0, "tomb_bunker_largeroom", "indoor", "_outdoor" );
    thread sndupdateambienttrigger( "tomb_overhang", 0, "tomb_overhang", "indoor", "_outdoor" );
    thread sndupdateambienttrigger( "tomb_overhang_prtl", 0, "tomb_overhang", "outdoor", "_outdoor" );
    thread sndupdateambienttrigger( "tomb_spiral_staircase", 0, "tomb_stairs", "indoor", "_indoor" );
    thread sndupdateambienttrigger( "tomb_church", 0, "tomb_church", "indoor", "_indoor" );
    thread sndupdateambienttrigger( "tomb_church_prtl", 0, "tomb_church", "outdoor", "_outdoor" );
}

sndupdateambienttrigger( name, is_default, reverb, context, inorout )
{
    weather = "_default";

    if ( !isdefined( level.sndambweathernames ) )
        level.sndambweathernames = [];

    level.sndambweathernames[level.sndambweathernames.size] = name;
    declareambientroom( name, is_default );
    declareambientpackage( name );
    setambientroomreverb( name, reverb, 1, 0.75 );
    setambientroomcontext( name, "ringoff_plr", context );
    setambientroomtone( name, "amb_weather_2d" + weather + inorout, 0.5, 0.5 );

    while ( true )
    {
        level waittill( "sndWeatherUpdate" );

        if ( is_true( level.sndweather.israin ) )
            weather = "_rain";
        else if ( is_true( level.sndweather.issnow ) )
            weather = "_snow";
        else
            weather = "_default";

        setambientroomtone( name, "amb_weather_2d" + weather + inorout, 0.5, 0.5 );
    }
}

sndweathersetup()
{
    level.sndweather = spawnstruct();
    level.sndweather.israin = 0;
    level.sndweather.issnow = 0;
}

sndambientcontextonplayer( room, player )
{
    switch ( room )
    {
        case "tomb_cave":
        case "tomb_large_chamber":
        case "tomb_robot_head":
        case "tomb_spiral_staircase_bot":
            setsoundcontext( "grass", "in_grass" );
            break;
        default:
            setsoundcontext( "grass", "no_grass" );
            break;
    }
}

sndcapturezonetrigs()
{
    trigs = getentarray( 0, "sndCaptureZone", "targetname" );

    if ( isdefined( trigs ) )
    {
        foreach ( trig in trigs )
        {
            trig.players = 0;
            trig.active = 0;
            trig thread sndcapturezonetrig();
        }
    }
}

sndcapturezonetrig()
{
    self thread sndcapturezonetrig_deactivate();

    while ( true )
    {
        self waittill( "trigger", who );

        if ( who isplayer() && !is_true( who.sndincapzone ) )
        {
            self.players++;
            who.sndincapzone = 1;
            self thread sndcapturezonetrig_player( who );

            if ( !self.active )
            {
                self.active = 1;
                self thread sndcapturezonetrig_activate();
            }
        }

        wait 0.05;
    }
}

sndcapturezonetrig_player( player )
{
    while ( isdefined( self ) && isdefined( player ) && player istouching( self ) )
        wait 0.1;

    self.players--;

    if ( isdefined( player ) )
        player.sndincapzone = 0;

    self notify( "player_left" );
}

sndcapturezonetrig_activate()
{
    playsound( 0, "zmb_zone_plate_down", self.origin );
    self playloopsound( "zmb_zone_plate_loop", 2 );
    self waittill( "zone_deactivate" );
    self.active = 0;
    self stoploopsound( 1 );
    playsound( 0, "zmb_zone_plate_up", self.origin );
}

sndcapturezonetrig_deactivate()
{
    while ( true )
    {
        self waittill( "player_left" );

        if ( self.players <= 0 )
        {
            self.players = 0;
            self notify( "zone_deactivate" );
        }
    }
}

init_audio_clientfields()
{
    registerclientfield( "toplayer", "sndMudSlow", 14000, 1, "int", clientscripts\mp\zm_tomb_amb::sndmudslow );
    registerclientfield( "world", "mus_zmb_egg_snapshot_loop", 14000, 1, "int", ::audio_snapshot_clientfield_callback, 1, 0 );
    registerclientfield( "world", "sndChamberMusic", 14000, 3, "int", ::sndchambermusic, 0 );
    registerclientfield( "world", "sndMaelstromPlr0", 14000, 1, "int", ::sndmaelstrom, 0 );
    registerclientfield( "world", "sndMaelstromPlr1", 14000, 1, "int", ::sndmaelstrom, 0 );
    registerclientfield( "world", "sndMaelstromPlr2", 14000, 1, "int", ::sndmaelstrom, 0 );
    registerclientfield( "world", "sndMaelstromPlr3", 14000, 1, "int", ::sndmaelstrom, 0 );
    level.sndchargeshot_func = ::sndchargeshot;
}

audio_snapshot_clientfield_callback( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    if ( newval )
        playloopat( fieldname, ( 0, 0, 0 ) );
    else
        stoploopat( fieldname, ( 0, 0, 0 ) );
}

sndchambermusic( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    if ( newval == 3 )
        level.sndchambermusoverride = "null";
    else if ( newval == 2 )
        level.sndchambermusoverride = "mus_underscore_chamber_fight_2";
    else if ( newval == 1 )
        level.sndchambermusoverride = "mus_underscore_chamber_fight_1";
    else
        level.sndchambermusoverride = undefined;
}

sndstartambience()
{
    thread snd_start_autofx_audio();
    thread flyovers();
}

snd_start_autofx_audio()
{
    snd_play_auto_fx( "fx_tomb_fire_sm", "amb_fire_sm", 0, 0, 0, 0 );
    snd_play_auto_fx( "fx_tomb_fire_lg", "amb_fire_lg", 0, 0, 0, 0 );
    snd_play_auto_fx( "fx_tomb_steam_md", "amb_pipe_steam_md", 0, 0, 0, 0 );
    snd_play_auto_fx( "fx_tomb_light_expensive", "amb_main_light", 0, 0, 0, 0 );
    snd_play_auto_fx( "fx_tomb_light_lg", "amb_light_lrg", 0, 0, 0, 0 );
    snd_play_auto_fx( "fx_tomb_light_md", "amb_light_md", 0, 0, 0, 0 );
}

flyovers()
{
    while ( true )
    {
        playsound( 0, "amb_flyover", ( 0, 0, 0 ) );
        wait( randomintrange( 2, 8 ) );
    }
}

sndmudslow( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    if ( !isspectating( localclientnum, 0 ) )
    {
        if ( newval == 1 )
            self thread sndactivatemudloop();
        else
            self thread snddeactivatemudloop();
    }
}

sndactivatemudloop()
{
    self endon( "stop_mud" );
    self endon( "entityshutdown" );

    if ( !isdefined( self.sndwadeent ) )
    {
        self.sndwadeent = spawn( 0, self.origin, "script_origin" );
        self.sndwadeent linkto( self, "tag_origin" );
    }

    self.sndwadeent playloopsound( "zmb_tomb_slowed_movement_loop", 1 );

    while ( true )
    {
        if ( !isdefined( self ) )
            return;

        mud_speed = abs( self getspeed() );
        mud_vol = scale_speed( 21, 285, 0.01, 1, mud_speed );
        self.sndwadeent setloopstate( "zmb_tomb_slowed_movement_loop", mud_vol, 1 );
        wait 0.1;
    }
}

snddeactivatemudloop()
{
    self notify( "stop_mud" );
    self.sndwadeent stoploopsound( 1.5 );
}

init()
{
    level._entityshutdowncbfunc = clientscripts\mp\zm_tomb_amb::heli_linkto_sound_ents_delete;
    level.helisoundvalues = [];
    init_heli_sound_values( "qrdrone", "turbine_idle", 30, 0.8, 0.0, 16, 0.9, 1.1 );
    init_heli_sound_values( "qrdrone", "turbine_moving", 30, 0.0, 0.9, 20, 0.9, 1.1 );
    init_heli_sound_values( "qrdrone", "turn", 5, 0, 1, 1, 1, 1 );
/#
    if ( getdvar( #"_id_21D60E03" ) == "" )
        setdvar( "helisounds", "" );

    level thread command_parser();
#/
}

init_heli_sound_values( heli_type, part_type, max_speed_vol, min_vol, max_vol, max_speed_pitch, min_pitch, max_pitch )
{
    if ( !isdefined( level.helisoundvalues[heli_type] ) )
        level.helisoundvalues[heli_type] = [];

    if ( !isdefined( level.helisoundvalues[heli_type][part_type] ) )
        level.helisoundvalues[heli_type][part_type] = spawnstruct();

    level.helisoundvalues[heli_type][part_type].speedvolumemax = max_speed_vol;
    level.helisoundvalues[heli_type][part_type].speedpitchmax = max_speed_pitch;
    level.helisoundvalues[heli_type][part_type].volumemin = min_vol;
    level.helisoundvalues[heli_type][part_type].volumemax = max_vol;
    level.helisoundvalues[heli_type][part_type].pitchmin = min_pitch;
    level.helisoundvalues[heli_type][part_type].pitchmax = max_pitch;
/#
    if ( getdvarint( #"_id_55AD9BED" ) > 0 )
    {
        println( "Init Heli Sounds heli_type: " + heli_type );
        println( "Init Heli Sounds part_type: " + part_type );
        println( "Init Heli Sounds max_speed_vol: " + max_speed_vol );
        println( "Init Heli Sounds min_vol: " + min_vol );
        println( "Init Heli Sounds max_vol: " + max_vol );
        println( "Init Heli Sounds max_speed_pitch: " + max_speed_pitch );
        println( "Init Heli Sounds min_pitch: " + min_pitch );
        println( "Init Heli Sounds max_pitch: " + max_pitch );
    }
#/
}

command_parser()
{
/#
    while ( true )
    {
        command = getdvar( #"_id_21D60E03" );

        if ( command != "" )
        {
            success = 1;
            tokens = strtok( command, " " );

            if ( !isdefined( tokens[0] ) || !isdefined( level.helisoundvalues[tokens[0]] ) )
            {
                if ( isdefined( tokens[0] ) )
                    println( "helisounds Did not recognize helicopter type:  " + tokens[0] );
                else
                    println( "helisounds Did not recognize helicopter type" );

                println( "helisounds usage: helisounds <heli name> <part name> <value name> <value>" );
                success = 0;
            }
            else if ( !isdefined( tokens[1] ) )
            {
                if ( isdefined( tokens[1] ) )
                    println( "helisounds Did not recognize helicopter part:  " + tokens[0] + " for heli: " + tokens[1] );
                else
                    println( "helisounds Did not recognize helicopter part for heli: " + tokens[0] );

                println( "helisounds usage: helisounds <heli name> <part name> <value name> <value>" );
                success = 0;
            }
            else if ( !isdefined( tokens[2] ) )
            {
                println( "helisounds Did not recognize helicopter value name for heli:" + tokens[0] + " part: " + tokens[1] );
                println( "helisounds usage: helisounds <heli name> <part name> <value name> <value>" );
                success = 0;
            }
            else if ( !isdefined( tokens[3] ) )
            {
                println( "helisounds Did not recognize helicopter value for heli:" + tokens[0] + " part: " + tokens[1] );
                println( "helisounds usage: helisounds <heli name> <part name> <value name> <value>" );
                success = 0;
            }

            if ( success )
            {
                heli_type = tokens[0];
                heli_part = tokens[1];
                value_name = tokens[2];
                value = float( tokens[3] );

                switch ( value_name )
                {
                    case "volumemin":
                        level.helisoundvalues[heli_type][heli_part].volumemin = value;
                        println( "Setting volumeMin to " + value );
                        break;
                    case "volumemax":
                        level.helisoundvalues[heli_type][heli_part].volumemax = value;
                        println( "Setting volumeMax to " + value );
                        break;
                    case "pitchmin":
                        level.helisoundvalues[heli_type][heli_part].pitchmin = value;
                        println( "Setting pitchMin to " + value );
                        break;
                    case "pitchmax":
                        level.helisoundvalues[heli_type][heli_part].pitchmax = value;
                        println( "Setting pitchMax to " + value );
                        break;
                    case "speedvolumemax":
                        level.helisoundvalues[heli_type][heli_part].speedvolumemax = value;
                        println( "Setting speedVolumeMax to " + value );
                        break;
                    case "speedpitchmax":
                        level.helisoundvalues[heli_type][heli_part].speedpitchmax = value;
                        println( "Setting speedPitchMax to " + value );
                        break;
                    default:
                        println( "no case match - helisounds usage: helisounds <heli name> <part name> <value name> <value>" );
                }
            }

            setdvar( "helisounds", "" );
        }

        wait 0.1;
    }
#/
}

init_heli_sounds_player_drone()
{
    setup_heli_sounds( "turbine_idle", "engine", "tag_body", "veh_qrdrone_turbine_idle" );
    setup_heli_sounds( "turbine_moving", "engine", "tag_body", "veh_qrdrone_turbine_moving" );
    setup_heli_sounds( "turn", "engine", "tag_body", "veh_qrdrone_idle_rotate" );
    self.warning_tag = undefined;
}

sound_linkto( parent, tag )
{
    if ( isdefined( tag ) )
        self linkto( parent, tag );
    else
        self linkto( parent, "tag_body" );
}

setup_heli_sounds( bone_location, type, tag, run, dmg1, dmg2, dmg3 )
{
    self.heli[bone_location] = spawnstruct();
    self.heli[bone_location].sound_type = type;
    self.heli[bone_location].run = spawn( 0, self.origin, "script_origin" );
    self.heli[bone_location].run sound_linkto( self, tag );
    self.heli[bone_location].run.alias = run;
    self thread heli_loop_sound_delete( self.heli[bone_location].run );

    if ( isdefined( dmg1 ) )
    {
        self.heli[bone_location].idle = spawn( 0, self.origin, "script_origin" );
        self.heli[bone_location].idle sound_linkto( self, tag );
        self.heli[bone_location].idle.alias = dmg1;
        self thread heli_loop_sound_delete( self.heli[bone_location].dmg1 );
    }

    if ( isdefined( dmg2 ) )
    {
        self.heli[bone_location].idle = spawn( 0, self.origin, "script_origin" );
        self.heli[bone_location].idle sound_linkto( self, tag );
        self.heli[bone_location].idle.alias = dmg2;
        self thread heli_loop_sound_delete( self.heli[bone_location].dmg2 );
    }

    if ( isdefined( dmg3 ) )
    {
        self.heli[bone_location].idle = spawn( 0, self.origin, "script_origin" );
        self.heli[bone_location].idle sound_linkto( self, tag );
        self.heli[bone_location].idle.alias = dmg3;
        self thread heli_loop_sound_delete( self.heli[bone_location].dmg3 );
    }
}

start_helicopter_sounds( localclientnum )
{
    if ( isdefined( self.vehicletype ) )
    {
        self.heli = [];
        self.terrain = [];
        self.sound_ents = [];
        self.cur_speed = 0;
        self.mph_to_inches_per_sec = 17.6;
        self.speed_of_wind = 20;
        self.idle_run_trans_speed = 5;
        self init_heli_sounds_player_drone();
        self play_player_drone_sounds();
    }
}

heli_loop_sound_delete( real_ent )
{
    self waittill( "entityshutdown" );
    real_ent unlink();
    real_ent stoploopsound( 4 );
    real_ent delete();
}

heli_linkto_sound_ents_delete( localclientnum, entity )
{
    entity notify( "entityshutdown" );
}

heli_sound_play( heli_bone )
{
    switch ( heli_bone.sound_type )
    {
        case "engine":
            heli_bone.run playloopsound( heli_bone.run.alias, 2 );
            break;
        case "wind":
            break;
        default:
/#
            println( "^6 unknown helicopter type: " + heli_bone.type + " expecting \"wind\" or \"engine\"" );
#/
            break;
    }
}

play_player_drone_sounds()
{
    self thread heli_idle_run_transition( "qrdrone", "turbine_idle", 0.1, 1 );
    self thread heli_idle_run_transition( "qrdrone", "turbine_moving", 0.1, 1 );
    self thread drone_up_down_transition();
    self thread drone_rotate_angle( "qrdrone", "turn" );
}

heli_idle_run_transition( heli_type, heli_part, wait_time, updown )
{
    self endon( "entityshutdown" );
    heli_bone = self.heli[heli_part];
    run_id = heli_bone.run playloopsound( heli_bone.run.alias, 0.5 );

    if ( !isdefined( wait_time ) )
        wait_time = 0.5;

    while ( isdefined( self ) )
    {
        if ( !isdefined( level.helisoundvalues[heli_type] ) || !isdefined( level.helisoundvalues[heli_type][heli_part] ) )
        {
/#
            println( "^5a speed vol/pitch parameter was not defined." );
#/
            return;
        }

        max_speed_vol = level.helisoundvalues[heli_type][heli_part].speedvolumemax;
        min_vol = level.helisoundvalues[heli_type][heli_part].volumemin;
        max_vol = level.helisoundvalues[heli_type][heli_part].volumemax;
        max_speed_pitch = level.helisoundvalues[heli_type][heli_part].speedpitchmax;
        min_pitch = level.helisoundvalues[heli_type][heli_part].pitchmin;
        max_pitch = level.helisoundvalues[heli_type][heli_part].pitchmax;
        plr_vel = self getvelocity();
        self.cur_speed = abs( sqrt( vectordot( plr_vel, plr_vel ) ) ) / self.mph_to_inches_per_sec;
        run_volume = scale_speed( self.idle_run_trans_speed, max_speed_vol, min_vol, max_vol, self.cur_speed );
        run_pitch = scale_speed( self.idle_run_trans_speed, max_speed_pitch, min_pitch, max_pitch, self.cur_speed );

        if ( isdefined( updown ) )
        {
            if ( !isdefined( self.qrdrone_z_difference ) )
                self.qrdrone_z_difference = 0;

            run_volume_vertical = scale_speed( 5, 50, 0, 1, abs( self.qrdrone_z_difference ) );
            run_volume = run_volume - run_volume_vertical;
        }

        if ( isdefined( run_volume ) && isdefined( run_pitch ) )
        {
            heli_bone.run setloopstate( heli_bone.run.alias, run_volume, run_pitch, 1, 0.15 );
/#
            if ( getdvarint( #"_id_55AD9BED" ) > 0 )
            {
                println( "^5a self.cur_speed = " + self.cur_speed );
                println( "^5a run_pitch . " + run_pitch );
                println( "^5a self.cur_speed = " + self.cur_speed );
                println( "^5a run_volume. " + run_volume );
            }
#/
        }

        wait( wait_time );
    }
}

get_heli_sound_ent( sound_ent )
{
    if ( !isdefined( sound_ent ) )
    {
        tag = "tag_origin";

        if ( isdefined( self.warning_tag ) )
            tag = self.warning_tag;

        sound_ent = spawn( 0, self gettagorigin( tag ), "script_origin" );
        sound_ent linkto( self, tag );
        self thread heli_sound_ent_delete( sound_ent );
    }

    return sound_ent;
}

get_lock_sound_ent()
{
    self.lock_sound_ent = get_heli_sound_ent( self.lock_sound_ent );
    return self.lock_sound_ent;
}

get_leaving_sound_ent()
{
    self.leaving_sound_ent = get_heli_sound_ent( self.leaving_sound_ent );
    return self.leaving_sound_ent;
}

heli_sound_ent_delete( real_ent )
{
    self waittill( "entityshutdown" );
    real_ent stoploopsound( 0.1 );
    real_ent delete();
}

drone_up_down_transition()
{
    self endon( "entityshutdown" );
    volumerate = 1;
    qr_ent_up = spawn( 0, self.origin, "script_origin" );
    qr_ent_down = spawn( 0, self.origin, "script_origin" );
    qr_ent_either = spawn( 0, self.origin, "script_origin" );
    qr_ent_up thread qr_ent_cleanup( self );
    qr_ent_down thread qr_ent_cleanup( self );
    qr_ent_either thread qr_ent_cleanup( self );
    self.qrdrone_z_difference = 0;
    down = qr_ent_down playloopsound( "veh_qrdrone_move_down" );
    qr_ent_down setloopstate( "veh_qrdrone_move_down", 0, 0 );
    up = qr_ent_up playloopsound( "veh_qrdrone_move_up" );
    qr_ent_up setloopstate( "veh_qrdrone_move_up", 0, 0 );
    either = qr_ent_either playloopsound( "veh_qrdrone_vertical" );
    qr_ent_either setloopstate( "veh_qrdrone_vertical", 0, 0 );
    tag = "tag_body";
    qr_ent_up linkto( self, tag );
    qr_ent_down linkto( self, tag );
    qr_ent_either linkto( self, tag );
    self thread drone_button_watch();

    while ( true )
    {
        last_pos = self.origin[2];
        wait 0.1;
        self.qrdrone_z_difference = last_pos - self.origin[2];

        if ( self.qrdrone_z_difference < 0 )
        {
            up_difference = self.qrdrone_z_difference * -1;
            run_volume_up = scale_speed( 5, 40, 0, 1, up_difference );
            run_pitch_up = scale_speed( 5, 40, 0.9, 1.1, up_difference );
            run_volume_either = scale_speed( 5, 50, 0, 1, up_difference );
            run_pitch_either = scale_speed( 5, 50, 0.9, 1.1, up_difference );
        }
        else
        {
            run_volume_up = 0;
            run_pitch_up = 1;
            run_volume_either = scale_speed( 5, 50, 0, 1, self.qrdrone_z_difference );
            run_pitch_either = scale_speed( 5, 50, 0.95, 0.8, self.qrdrone_z_difference );
        }

        run_volume_down = scale_speed( 5, 50, 0, 1, self.qrdrone_z_difference );
        run_pitch_down = scale_speed( 5, 50, 1, 0.8, self.qrdrone_z_difference );
        qr_ent_down setloopstate( "veh_qrdrone_move_down", run_volume_down, run_pitch_down, volumerate );
        qr_ent_up setloopstate( "veh_qrdrone_move_up", run_volume_up, run_pitch_up, volumerate );
        qr_ent_either setloopstate( "veh_qrdrone_vertical", run_volume_either, run_pitch_either, volumerate );
    }
}

qr_ent_cleanup( veh_ent )
{
    veh_ent waittill( "entityshutdown" );
    self delete();
}

drone_rotate_angle( heli_type, heli_part )
{
    self endon( "entityshutdown" );
    level endon( "save_restore" );
    volumerate = 2.5;
    qr_ent_angle = spawn( 0, self.origin, "script_origin" );
    qr_ent_angle thread qr_ent_cleanup( self );
    angle = qr_ent_angle playloopsound( "veh_qrdrone_idle_rotate" );
    setsoundvolume( angle, 0 );
    tag = "tag_body";
    qr_ent_angle linkto( self, tag );

    while ( true )
    {
        last_angle = abs( self.angles[1] );
        wait 0.1;
        turning_speed = last_angle - abs( self.angles[1] );
        abs_turning_speed = abs( turning_speed );
        jet_stick_vol = scale_speed( 0, 5, 0, 0.4, abs_turning_speed );
        jet_stick_pitch = scale_speed( 0, 4, 0.9, 1.05, abs_turning_speed );
        qr_ent_angle setloopstate( "veh_qrdrone_idle_rotate", jet_stick_vol, jet_stick_pitch, volumerate );
    }
}

drone_button_watch()
{
    self endon( "entityshutdown" );
    player = getlocalplayers()[0];
    return_to_zero = 1;

    while ( true )
    {
        if ( abs( self.qrdrone_z_difference ) > 5 && return_to_zero )
        {
            self playsound( 0, "veh_qrdrone_move_start" );
            return_to_zero = 0;
        }
        else if ( abs( self.qrdrone_z_difference ) < 5 && !return_to_zero )
            return_to_zero = 1;

        wait 0.05;
    }
}

snd_shake_hvy()
{
    playsound( 0, "amb_interior_shake_hvy", ( 2725, 5338, -244 ) );
    wait 0.05;
    playsound( 0, "amb_interior_shake_hvy", ( 1756, 4124, -244 ) );
    wait 0.05;
    playsound( 0, "amb_interior_shake_hvy", ( 1262, 3917, -213 ) );
    wait 0.05;
    playsound( 0, "amb_interior_shake_hvy", ( -262, 4168, -250 ) );
    wait 0.05;
    playsound( 0, "amb_interior_shake_hvy", ( 1078, 4207, -224 ) );
    wait 0.05;
    playsound( 0, "amb_interior_shake_hvy", ( 1309, 2871, -114 ) );
    wait 0.05;
    playsound( 0, "amb_interior_shake_hvy", ( 452, 3472, -194 ) );
    wait 0.05;
    playsound( 0, "amb_interior_shake_hvy", ( -686, 3432, -181 ) );
    wait 0.05;
    playsound( 0, "amb_interior_shake_hvy", ( -944, 2939, -142 ) );
    wait 0.05;
    playsound( 0, "amb_interior_shake_hvy", ( -416, 2967, -140 ) );
    wait 0.05;
    playsound( 0, "amb_interior_shake_hvy", ( -477, 2452, -143 ) );
    wait 0.05;
    playsound( 0, "amb_interior_shake_hvy", ( -906, 2391, -141 ) );
    wait 0.05;
    playsound( 0, "amb_interior_shake_hvy", ( -751, 2668, -8 ) );
    wait 0.05;
    playsound( 0, "amb_interior_shake_hvy", ( -1, 23, 300 ) );
    wait 0.05;
    playsound( 0, "amb_interior_shake_hvy", ( 701, 2693, -142 ) );
    wait 0.05;
    playsound( 0, "amb_interior_shake_hvy", ( 2181, 4785, -182 ) );
    wait 0.05;
    playsound( 0, "amb_interior_shake_hvy", ( 1701, 3312, -163 ) );
    wait 0.05;
    playsound( 0, "amb_interior_shake_hvy", ( -2575, 165, 214 ) );
}

snd_shake_med()
{
    playsound( 0, "amb_interior_shake_med", ( 2725, 5338, -244 ) );
    wait 0.05;
    playsound( 0, "amb_interior_shake_med", ( 1756, 4124, -244 ) );
    wait 0.05;
    playsound( 0, "amb_interior_shake_med", ( 1262, 3917, -213 ) );
    wait 0.05;
    playsound( 0, "amb_interior_shake_med", ( -262, 4168, -250 ) );
    wait 0.05;
    playsound( 0, "amb_interior_shake_med", ( 1078, 4207, -224 ) );
    wait 0.05;
    playsound( 0, "amb_interior_shake_med", ( 1309, 2871, -114 ) );
    wait 0.05;
    playsound( 0, "amb_interior_shake_med", ( 452, 3472, -194 ) );
    wait 0.05;
    playsound( 0, "amb_interior_shake_med", ( -686, 3432, -181 ) );
    wait 0.05;
    playsound( 0, "amb_interior_shake_med", ( -944, 2939, -142 ) );
    wait 0.05;
    playsound( 0, "amb_interior_shake_med", ( -416, 2967, -140 ) );
    wait 0.05;
    playsound( 0, "amb_interior_shake_med", ( -477, 2452, -143 ) );
    wait 0.05;
    playsound( 0, "amb_interior_shake_med", ( -906, 2391, -141 ) );
    wait 0.05;
    playsound( 0, "amb_interior_shake_med", ( -751, 2668, -8 ) );
    wait 0.05;
    playsound( 0, "amb_interior_shake_med", ( -1, 23, 300 ) );
    wait 0.05;
    playsound( 0, "amb_interior_shake_med", ( 701, 2693, -142 ) );
    wait 0.05;
    playsound( 0, "amb_interior_shake_med", ( 2181, 4785, -182 ) );
    wait 0.05;
    playsound( 0, "amb_interior_shake_med", ( 1701, 3312, -163 ) );
    wait 0.05;
    playsound( 0, "amb_interior_shake_med", ( -2575, 165, 214 ) );
}

snd_shake_lgt()
{
    playsound( 0, "amb_interior_shake_lgt", ( 2725, 5338, -244 ) );
    wait 0.05;
    playsound( 0, "amb_interior_shake_lgt", ( 1756, 4124, -244 ) );
    wait 0.05;
    playsound( 0, "amb_interior_shake_lgt", ( 1262, 3917, -213 ) );
    wait 0.05;
    playsound( 0, "amb_interior_shake_lgt", ( -262, 4168, -250 ) );
    wait 0.05;
    playsound( 0, "amb_interior_shake_lgt", ( 1078, 4207, -224 ) );
    wait 0.05;
    playsound( 0, "amb_interior_shake_lgt", ( 1309, 2871, -114 ) );
    wait 0.05;
    playsound( 0, "amb_interior_shake_lgt", ( 452, 3472, -194 ) );
    wait 0.05;
    playsound( 0, "amb_interior_shake_lgt", ( -686, 3432, -181 ) );
    wait 0.05;
    playsound( 0, "amb_interior_shake_lgt", ( -944, 2939, -142 ) );
    wait 0.05;
    playsound( 0, "amb_interior_shake_lgt", ( -416, 2967, -140 ) );
    wait 0.05;
    playsound( 0, "amb_interior_shake_lgt", ( -477, 2452, -143 ) );
    wait 0.05;
    playsound( 0, "amb_interior_shake_lgt", ( -906, 2391, -141 ) );
    wait 0.05;
    playsound( 0, "amb_interior_shake_lgt", ( -751, 2668, -8 ) );
    wait 0.05;
    playsound( 0, "amb_interior_shake_lgt", ( -1, 23, 300 ) );
    wait 0.05;
    playsound( 0, "amb_interior_shake_lgt", ( 701, 2693, -142 ) );
    wait 0.05;
    playsound( 0, "amb_interior_shake_lgt", ( 2181, 4785, -182 ) );
    wait 0.05;
    playsound( 0, "amb_interior_shake_lgt", ( 1701, 3312, -163 ) );
    wait 0.05;
    playsound( 0, "amb_interior_shake_lgt", ( -2575, 165, 214 ) );
}

snd_play_loopers()
{
    playloopat( "amb_cave_enter", ( 2352, 4138, -278 ) );
    playloopat( "amb_cave_enter", ( 2176, 807, 107 ) );
    playloopat( "amb_cave_enter", ( -2433, 494, 220 ) );
    playloopat( "mus_elemental_air", ( 11279, -8683, -271 ) );
    playloopat( "mus_elemental_fire", ( 9459, -8564, -283 ) );
    playloopat( "mus_elemental_lightning", ( 9616, -6973, -252 ) );
    playloopat( "mus_elemental_ice", ( 11252, -7040, -215 ) );
    playloopat( "amb_plane_dist_loop", ( 636, 5382, 453 ) );
    playloopat( "amb_plane_dist_loop", ( 2515, 2411, 377 ) );
    playloopat( "amb_plane_dist_loop", ( -76, 58, 1035 ) );
    playloopat( "amb_plane_dist_loop", ( -2452, -690, 818 ) );
    playloopat( "amb_plane_dist_loop", ( 886, -4399, 1051 ) );
    playloopat( "amb_plane_dist_loop", ( 1078, 2266, 744 ) );
    playloopat( "amb_spawn_rays", ( 9514, -8741, -335 ) );
    playloopat( "amb_spawn_rays", ( 9319, -8519, -295 ) );
    playloopat( "amb_spawn_rays", ( 9391, -7986, -258 ) );
    playloopat( "amb_spawn_rays", ( 9322, -7608, -165 ) );
    playloopat( "amb_spawn_rays", ( 9322, -7608, -165 ) );
    playloopat( "amb_spawn_rays", ( 9369, -7021, -269 ) );
    playloopat( "amb_spawn_rays", ( 9730, -6749, -175 ) );
    playloopat( "amb_spawn_rays", ( 9997, -7007, -200 ) );
    playloopat( "amb_spawn_rays", ( 10262, -7362, -341 ) );
    playloopat( "amb_spawn_rays", ( 10985, -6684, -3 ) );
    playloopat( "amb_spawn_rays", ( 11542, -7255, -291 ) );
    playloopat( "amb_spawn_rays", ( 11291, -7653, -235 ) );
    playloopat( "amb_spawn_rays", ( 11327, -8091, -203 ) );
    playloopat( "amb_spawn_rays", ( 11596, -8545, -222 ) );
    playloopat( "amb_spawn_rays", ( 11102, -889, -305 ) );
    playloopat( "amb_spawn_rays", ( 10586, -8794, -225 ) );
    playloopat( "amb_spawn_rays", ( 10117, -8888, -264 ) );
    playloopat( "amb_spawn_rays", ( 10048, -8431, -321 ) );
    playloopat( "amb_spawn_rays", ( 11104, -8896, -300 ) );
    playloopat( "amb_spawn_rays", ( 10416, -7055, -337 ) );
    playloopat( "amb_spawn_rays", ( 11100, -8894, -303 ) );
    playloopat( "zmb_sq_electric_pillar", ( 10091, -7663, -372 ) );
    playloopat( "zmb_sq_ice_pillar", ( 10567, -7657, -372 ) );
    playloopat( "zmb_sq_air_pillar", ( 10581, -8142, -377 ) );
    playloopat( "zmb_sq_fire_pillar", ( 10106, -8147, -382 ) );
    playloopat( "amb_robot_fans", ( -6252, -6534, 398 ) );
    playloopat( "amb_robot_fans", ( -6767, -6543, 361 ) );
    playloopat( "amb_robot_fans", ( -5677, -6501, 405 ) );
}

sndchargeshot( localclientnum, weaponname, chargeshotlevel )
{
    self.sndcurrentcharge = chargeshotlevel;

    if ( !isdefined( self.sndchargeloopent ) )
        self.sndchargeloopent = spawn( 0, ( 0, 0, 0 ), "script_origin" );

    self thread sndstoploopent();

    if ( !isdefined( self.sndlastcharge ) || self.sndcurrentcharge != self.sndlastcharge )
    {
        alias = "wpn_firestaff_charge_";

        if ( weaponname == "staff_water_upgraded_zm" )
            alias = "wpn_waterstaff_charge_";
        else if ( weaponname == "staff_lightning_upgraded_zm" )
            alias = "wpn_lightningstaff_charge_";
        else if ( weaponname == "staff_air_upgraded_zm" )
            alias = "wpn_airstaff_charge_";

        self.sndchargeloopent playloopsound( alias + "loop", 1.5 );
        playsound( localclientnum, alias + self.sndcurrentcharge, ( 0, 0, 0 ) );
        self.sndlastcharge = self.sndcurrentcharge;
    }
}

sndstoploopent()
{
    level notify( "sndStopThisFUnction" );
    level endon( "sndStopThisFUnction" );
    wait 0.5;
    self.sndchargeloopent stoploopsound( 0.1 );
    self.sndcurrentcharge = 0;
}

sndtombbgsetup()
{
    waitforclient( 0 );
    trigs = getentarray( 0, "sndBG", "targetname" );

    foreach ( trig in trigs )
        trig thread sndtombbgtriggers( 0 );

    player = getlocalplayers()[0];
    player thread sndtombbgplayers( 0 );
}

sndtombbgplayers( localclientnum )
{
    self endon( "disconnect" );
    self.sndent = spawn( 0, ( 0, 0, 0 ), "script_origin" );
    self.sndbgalias = "mus_underscore_default";
    self.sndbgaliaslast = "null";

    while ( true )
    {
        if ( self.sndbgaliaslast != self.sndbgalias )
        {
            self.sndbgaliaslast = self.sndbgalias;
            self.sndent notify( "sndBackgroundChanging" );
            self.sndent thread sndtombbgmusic( self.sndbgalias );
        }

        wait 2;
    }
}

sndtombbgtriggers( localclientnum )
{
    self endon( "disconnect" );
    self endon( "death" );

    while ( true )
    {
        self waittill( "trigger", who );

        if ( isdefined( who ) && who islocalplayer() )
        {
            if ( isdefined( level.sndchambermusoverride ) && self.script_sound == "mus_underscore_chamber" )
                who.sndbgalias = level.sndchambermusoverride;
            else
                who.sndbgalias = self.script_sound;

            who thread sndtombbgtrigger_timeout();
        }

        wait 0.5;
    }
}

sndtombbgtrigger_timeout()
{
    self notify( "sndBGTImeout" );
    self endon( "disconnect" );
    self endon( "sndBGTImeout" );
    wait 4;

    if ( isdefined( self ) && self islocalplayer() )
        self.sndbgalias = "mus_underscore_default";
}

sndtombbgmusic( alias )
{
    self endon( "sndBackgroundChanging" );
    self endon( "death" );
    self stoploopsound( 2 );
    wait 2;
    self playloopsound( alias, 2 );
}

sndmaelstrom( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    if ( !isdefined( level.sndmaelstrom ) )
        level.sndmaelstrom = spawn( 0, ( 0, 0, 0 ), "script_origin" );

    players = getlocalplayers();

    foreach ( player in players )
    {
        fn = "sndMaelstromPlr" + player getentitynumber();

        if ( fn == fieldname )
        {
            if ( newval == 1 )
            {
                level.sndmaelstrom playloopsound( "amb_maelstrom", 3 );
                continue;
            }

            level.sndmaelstrom stoploopsound( 3 );
        }
    }
}
